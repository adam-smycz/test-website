<!doctype html><html lang="en"><head><style>.TLCOVER {position: fixed; height: 100%; width: 100%; top:0; left: 0; background: #000; z-index:2147483647;}</style><script>  var observeDOM = (function(){
      var MutationObserver = window.MutationObserver || window.WebKitMutationObserver,
          eventListenerSupported = window.addEventListener;

      return function(obj, callback){
          if( MutationObserver ){
			  // define a new observer
			  var obs = new MutationObserver(function(mutations, observer){
			      //if( mutations[0].addedNodes.length || mutations[0].removedNodes.length )
				  console.log("observed, invoke callback");
				  callback();
			  });
		      // have the observer observe foo for changes in children
		      obs.observe( obj, { childList:true, subtree:true });
          } else if( eventListenerSupported ){
		      obj.addEventListener('DOMSubtreeModified', callback, false);
		      // obj.addEventListener('DOMNodeInserted', callback, false);
		      // obj.addEventListener('DOMNodeRemoved', callback, false);
          }
      };
  })();
  
function addShadows() {
    var tlShadow = document.getElementById("TLSHADOW");
    if (tlShadow) {
    	var shadows = JSON.parse(tlShadow.innerHTML);
    	if (shadows) {
            for (i = 0, len = shadows.length; i < len; i += 1) {
                var currentNode = TeaLeaf_Client_tlGetNodeFromXPath_v2(shadows[i].xpath, -2);
                if (currentNode) {
                    try {
                        shadowRoot = currentNode.attachShadow({ mode: "open" });
                        shadowRoot.innerHTML = shadows[i].root;
                    } catch (e) {
                        console.error("Exception when adding shadow DOM: ", e);
                    }
                    if(shadows[i].frames && shadows[i].frames.length > 0){
                        for (j = 0, len2 = shadows[i].frames.length; j < len2; j += 1) {
                            var iframe = shadowRoot.querySelector('iframe[tltid="'+shadows[i].frames[j].tltid+'"]');
                            var frameDoc = iframe.contentWindow.document;
                            frameDoc.open();
                            frameDoc.write("");
                            frameDoc.write(shadows[i].frames[j].root);
                            frameDoc.close();
                            if(shadows[i].frames[j].shadows && shadows[i].frames[j].shadows.length > 0){
                                for (k = 0, len3 = shadows[i].frames[j].shadows.length; k < len3; k += 1) {
                                    addShadow(JSON.stringify(shadows[i].frames[j].shadows[k]));
                                }
                            }
                        }
                    }
                }
            }
    	}
    }
}

function addShadow(tlShadow) {
    if (tlShadow) {
        var shadow = JSON.parse(tlShadow);
        if (shadow) {
            var currentNode = TeaLeaf_Client_tlGetNodeFromXPath_v2(shadow.xpath, -2);
            if (currentNode) {
                try {
                    shadowRoot = currentNode.attachShadow({ mode: "open" });
                    shadowRoot.innerHTML = shadow.root;
                } catch (e) {
                    console.error("Exception when adding shadow DOM: ", e);
                }
                if(shadow.frames && shadow.frames.length > 0){
                    var iframe = shadowRoot.querySelector('iframe');
                    for (j = 0, len2 = shadow.frames.length; j < len2; j += 1) {
                        if(shadow.frames[j].shadows && shadow.frames[j].shadows.length > 0){
                            var iframe = shadowRoot.querySelector('iframe[tltid="'+shadow.frames[j].tltid+'"]');
                            var frameDoc = iframe.contentWindow.document;
                            frameDoc.open();
                            frameDoc.write("");
                            frameDoc.write(shadow.frames[j].root);
                            frameDoc.close();
                            for (k = 0, len3 = shadow.frames[j].shadows.length; k < len3; k += 1) {
                                  addShadow(shadow.frames[j].shadows[k]);
                            }
                        }
                    }
                }
            }
        }
    }
}

function moveHighlight2Pos(x, y) {
    var scrollX = 0;
    var scrollY = 0;

    //calulate scrolls, to get absolute position
    if (window.scrollX) {
        scrollX = window.scrollX;
        scrollY = window.scrollY;

    } else {
        scrollX = (window.pageXOffset !== undefined) ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;

        scrollY = (window.pageYOffset !== undefined) ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;
    }

    //add scrolls to the offsets
    newLeft = x + scrollX;
    newTop = y + scrollY;
    newLeft = newLeft.toFixed(0);
    newTop = newTop.toFixed(0);
	
    var tlCircle = document.getElementById("tealCircle");
    //move
    if (newLeft > 30) {
        newLeft = newLeft - 30;
    } else {
        newLeft = 0;
    }
    if (newTop > 30) {
        newTop = newTop - 30;
    } else {
        newTop = 0;
    }
    tlCircle.style.left = "" + (newLeft) + "px";
    tlCircle.style.top = "" + (newTop) + "px";
    tlCircle.style.display = "block";
}

function moveHighlight(id, idType) {
    var tlCircle = document.getElementById("tealCircle"),
    currentNode = TeaLeaf_Client_tlGetNodeFromXPath_v2(id, idType);
    console.log("---> id passed to TeaLeaf_Client_tlGetNodeFromXPath_v2(): " + id);

    if (!currentNode) {

       console.log("---> Unable to resolve currentNode: " + currentNode);

       tlCircle.style.display = "none";

       return;

    }
    // If currentNode is a slot element getBoundingClientRect() returns coordinates of 0.

    // In that situation, use the parent element instead.
    try {

       currentNode.assignedNodes();

       currentNode = currentNode.parentNode;

    } 
    catch (e) {
    console.log("---> currentNode is not a slot element: " + e);
    }

    if (currentNode != null) {
		//make the node appear in the viewport prior to calulating the position of tlCircle
// 		currentNode.scrollIntoView({
//                     behavior: 'auto',
//                     block: 'center',
//                     inline: 'center'
//                 });
	
    	//native session 
    	if (currentNode.hasAttribute("templatetype") && currentNode.getAttribute("templatetype") == "radioButton") {
    	    var radioElements = document.querySelectorAll("[id='" + id + "']");
    	    if (radioElements) {
    	        for (var i = 0; i < radioElements.length; i++) {
	                var radioInput = radioElements[i].getElementsByTagName('INPUT');
	                if (radioInput && radioInput[0] && radioInput[0].hasAttribute("checked")) {
	                	currentNode = radioElements[i];
	                	break;
	                }
    	        }
    	    }
    	}
    	
        var rect = currentNode.getBoundingClientRect();
        tagName = currentNode.tagName.toUpperCase();
        if (tagName == 'A' || currentNode.tagName == 'SPAN') {
        	//handle inline elements when they're wrapped
            var rects = currentNode.getClientRects();
            if (rects.length > 1) {
                rect = rects[0];
                for (var i = 1; i != rects.length; i++) {
                    if (rects[i].width > rect.width) {
                        rect = rects[i];
                    }
                }
            }
        }
        
        var newLeft = (rect.left + rect.right) / 2;
        
        if (rect.width > 100) {
        	hlrelx = document.getElementById("tealeaf_hl_relx");
        	if (hlrelx && hlrelx.innerHTML.length > 0) {
        		relx = parseFloat(hlrelx.innerHTML);
        		newLeft = rect.left+(rect.right-rect.left) * relx;
        	}
        }
        var newTop = (rect.top + rect.bottom) / 2;
        
        if (rect.height > 100) {
        	hlrely = document.getElementById("tealeaf_hl_rely");
        	if (hlrely && hlrely.innerHTML.length > 0) {
        		rely = parseFloat(hlrely.innerHTML);
        		newTop = rect.top+(rect.bottom-rect.top) * rely;
        	}
        }
        var scrollX = 0;
        var scrollY = 0;

        //calulate scrolls, to get absolute position
        if (window.scrollX) {
            scrollX = window.scrollX;
            scrollY = window.scrollY;

        } else {
            scrollX = (window.pageXOffset !== undefined) ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft;

            scrollY = (window.pageYOffset !== undefined) ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop;
        }

        //add scrolls to the offsets
        newLeft += scrollX;
        newTop += scrollY;
        newLeft = newLeft.toFixed(0);
        newTop = newTop.toFixed(0);


        if (newLeft < 0 || newTop < 0) {
            tlCircle.style.display = "none";
        } else {
            //update image
            svg = document.getElementById("tealeaf_hl_svg");
            img = document.getElementById("tealeafhlimg");
            if (svg && img) {
                img.setAttribute("xlink:href", svg.innerHTML);
            }

            //move
            if (newLeft > 30) {
                newLeft = newLeft - 30;
            } else {
                newLeft = 0;
            }
            if (newTop > 30) {
                newTop = newTop - 30;
            } else {
                newTop = 0;
            }
            tlCircle.style.left = "" + (newLeft) + "px";
            tlCircle.style.top = "" + (newTop) + "px";
            tlCircle.style.display = "block";
        }
      tlCircle.scrollIntoView({
                    behavior: 'auto',
                    block: 'center',
                    inline: 'center'
                }); //for vikas' testing
        //currentNode.scrollIntoView(false); //for vikas' testing
    } else {
		tlCircle.style.display = "none";
    }
}

function highlightHandler() {
	hlsvg = document.getElementById("tealeaf_hl_svg");
	if (hlsvg) {
		svg = hlsvg.innerHTML;
		img = document.getElementById("tealeafhlimg");
		if (img) {
			img.setAttribute("xlink:href", svg);
		}
	}
	var moved = false;
	/*
	hlx = document.getElementById("tealeaf_hl_x");
	hly = document.getElementById("tealeaf_hl_y");
	if (hlx && hly) {
		x = hlx.innerHTML;
		y = hly.innerHTML;
		if (x && x.length > 0 && y && y.length > 0) {
			moveHighlight2Pos(parseInt(x), parseInt(y));
			moved = true;
		}
	}*/

	if (moved == false) {
		hlid = document.getElementById("tealeaf_hl_id");
		hlidtype = document.getElementById("tealeaf_hl_idtype");
		if (hlid && hlidtype) {
			id = hlid.innerHTML;
			idType = hlidtype.innerHTML;
			if (id && id.length > 0) {
				moveHighlight(id, idType);
				moved = true;
			}
		}
	}
	if (moved == false) {
	    var tlCircle = document.getElementById("tealCircle");
	    tlCircle.style.display = "none";
	}
}

function getXY(element, xOffset, yOffset) {
	if (element == null) {
		//alert('Invalid element passed to getXY.');
        return [-1, -1];
    }

    var x = 0,
            y = 0,
            elementReference = element;

    if (elementReference.offsetParent) {
        do {
            x += elementReference.offsetLeft;
            y += elementReference.offsetTop;
        } while (!!(elementReference = elementReference.offsetParent));
    }

    return [x + parseInt(xOffset, 10) - document.documentElement.scrollLeft, y + parseInt(yOffset, 10)];
}


function doMouseEvents (node, xpath, clientX, clientY, doClick, doBubble) {
        var x = 0;
        var y = 0;
        try {
            var tmp = getXY(node, clientX, clientY);
            if (tmp && tmp[0]) {
                x = tmp[0];
                y = tmp[1];
            }
        }
        catch (e) { 
        }
        mouseEvent(node, "mousedown", x, y, clientX, clientY);
        mouseEvent(node, "mouseup", x, y, clientX, clientY);
        if (doClick) {
            mouseEvent(node, "click", x, y, clientX, clientY);
        }
    }

	function mouseEvent(node, evt, x, y, clientX, clientY) {
        if (document.createEvent) {
        //if (false) {
            var evObj = document.createEvent('MouseEvents');
if (evObj == null) {
	//alert("evObj == null");
} else {
	//alert("evObj != null");
}            
            evObj.initMouseEvent(evt, true, true, window,
                1, x, y, clientX, clientY, false, false, false,
                false, 0, null);
			try {
	            node.dispatchEvent(evObj);
			} catch (e) {
			}
        }
        else {
            try {
                var evObj = document.createEventObject();
                evObj.clientX = clientX;
                evObj.clientY = clientY;
                node.fireEvent('on' + evt, evObj);
            } catch (e) { 
            	
            }
        }
    }

    function fireEvent(node, evt) {
        if (document.createEvent) {
            var evObj = document.createEvent('Events');
            evObj.initEvent(evt, true, true);
            node.dispatchEvent(evObj);
        }
        else {
            try {
                var evObj = document.createEventObject();
                node.fireEvent('on' + evt, evObj);
            } catch (e) { }
        }
    }
    
    function TeaLeaf_Client_tlGetNodeFromXPath_v2(selector, type) {

        var idTypes = {
            HTML_ID: -1,
            XPATH_ID: -2,
            ATTRIBUTE_ID: -3,
            MOBILE_ID: -4
        },
            xpath;

        /**
        * Find one or more elements using a XPath selector.
        * @function
        * @name browserService-queryDom.xpath
        * @param  {String} query The XPath query to search for.
        * @param  {Object} [scope="document"] The DOM subtree to run the query in.
        * @return {Object}       Returns the DOM element matching the XPath.
        * @todo test the xpath implementation and probably fix it.
        */
        xpath = (function () {

            var __strToArr = typeof JSON === "object" && typeof JSON.parse === "function" ?
                function (xpathStr) { return JSON.parse(String(xpathStr)); } :
                function (xpathStr) { return eval(String(xpathStr)); };

            return function (query, scope) {
                var xpath = __strToArr(query),
                    elem,
                    pathElem = null,
                    tagName,
                    pathElemIsHost,
                    
                    i, j, k, len, jlen;

                if (typeof scope !== "undefined") {
                	//alert("scope is defined");
                } else {
                	//alert(" set scope to document");
                }
                scope = typeof scope !== "undefined" ? scope : document;
                elem = scope;
                
                if (!xpath) {
                    return null;
                }

                //alert("xpath.length = " + xpath.length);

                for (i = 0, len = xpath.length; i < len && elem; ++i) {
                    //alert("i = " + i);
                    pathElem = xpath[i];
                    pathElemIsHost = pathElem.length > 1 && pathElem[pathElem.length - 1] === "h";
                    if (pathElem.length === 1 || (pathElem.length === 2 && pathElemIsHost)) {
                        elem = scope.getElementById(pathElem[0]);
                    } else {
                        for (j = 0, k = -1, jlen = elem.childNodes.length; j < jlen; ++j) {
                            if (elem.childNodes[j].nodeType === 1 && elem.childNodes[j].tagName.toUpperCase() === pathElem[0].toUpperCase()) {
                                if (++k === pathElem[1]) {
                                    elem = elem.childNodes[j];
                                    break;
                                }
                            }
                        }
                        if (k !== pathElem[1]) {
                        	console.log("Unable to locate xpath component (" + i + ") " + pathElem[0]);
                            return null;
                        }
                    }
                    
                    if (!elem) {
                    	console.log("Unable to locate xpath component (" + i + ") " + pathElem[0]);
                    	return null;
                    }
                    
                    if (pathElemIsHost) {
                        if (i < len - 1) {
                            if (!elem.shadowRoot) {
                                console.log("Host (" + i + ") " + pathElem[0] + " does not have a shadow root or the shadow root is not accessible.");
                                return null;
                            }
                            elem = elem.shadowRoot;
                            scope = elem;
                        }
                    }
                    
                    // Handle IFRAMEs
                    if (elem.contentWindow) {
                        scope = elem.contentWindow.document;
                        elem = scope;
                    }
                }

                return elem === scope || !elem ? null : elem;
            };
        }());
        /**
         * Helper function to transform a nodelist into an array.
         * @function
         * @name browserService-queryDom.list2Array
         * @param  {List} nodeList Pass in a DOM NodeList
         * @return {Array}          Returns an array.
         */
         function list2Array(nodeList) {
             var len = nodeList.length,
                 result = [],
                 i;
             if (typeof nodeList.length === "undefined") {
                 return [nodeList];
             }
             for (i = 0; i < len; i += 1) {
                 result[i] = nodeList[i];
             }
             return result;
         }
         
         if (type == idTypes.HTML_ID || type == idTypes.MOBILE_ID) {
             return document.getElementById(selector);
         } else if (type == idTypes.ATTRIBUTE_ID) {
             parts = selector.split("=");
             return document.querySelector("[" + parts[0] + "=\"" + parts[1] + "\"]");
         } else if (type == idTypes.XPATH_ID) {
             return xpath(selector);
         }

     }

    function execute(node, elementValue, subType, xpath, clientX, clientY, isParentLink, curStateIsChecked, curStateIsSelected, curStateIsOn, curStateButtonIndex, curStateValue, curStateMaxValue, curStateCurrentPage, curStateSelectedColumn, curStateVisibleCols, curStateNumberOfColumns, curStateVisiblePics) {
        try {
            if (clientX == null) clientX = -1;
            if (clientY == null) clientY = -1;

            if (node) {
                var type = "";
                var tag = "";
                if (typeof (node.type) != "undefined")
                    type = node.type.toLowerCase();
                if (typeof (node.tagName) != "undefined")
                    tag = node.tagName.toLowerCase();
                
                if (elementValue.length) {
                    if (clientX != -1 && clientY != -1 && subType.toLowerCase() !== "click") {
                        doMouseEvents(node, xpath, clientX, clientY, true, isParentLink);
                    }
                    if (type == "select" || tag == "select") {
                        var opts = node.options;
                        if (opts != null) {
                            for (i = 0; i < opts.length; i++) {
                                var optionValue = opts[i].getAttribute("value") || opts[i].getAttribute("label") || opts[i].text;
                                if (optionValue === elementValue) {
                                    node.selectedIndex = i;
                                    break;
                                }
                            }
                        }
                    }
                    else if (tag == "td")
                        node.innerHTML = elementValue;
                    else
                        node.value = elementValue;
                    if (type == "radio") {
                        node.checked = 1;
                    }
                    else if (type == "checkbox") {
                        node.checked = elementValue == "1" ? 1 : 0;
                    }
                    fireEvent(node, 'change');
                }
                if (subType == "mousedown") {
                    node.focus();
                    if (clientX != -1 && clientY != -1)
                        doMouseEvents(node, xpath, clientX, clientY, false, isParentLink);
                    else {
                        // Is this correct?
                        node.click();
                    }
                }
                if (subType == "mouseover") {
                    node.onmouseover();
                }
                if (subType == "click") {
                    node.focus();
                    if (clientX != -1 && clientY != -1)
                        doMouseEvents(node, xpath, clientX, clientY, true, isParentLink);
                    else {
                    	node.click();
                    }
                }
                if (subType == "onblur") {
                    fireEvent(node, 'blur');
                }
                if (subType == "KeyUp") {
                    fireEvent(node, 'keyup');
                }
                
                // Android native replay for toggleButton
                if (subType == "click" && (elementValue.toLowerCase() == "on" || elementValue.toLowerCase() == "off")) {
                    var labels = node.getElementsByTagName("label");
                    if (labels && labels[0]) {
                        if (labels[0].innerText) {
                            // Chrome
                            labels[0].innerText = elementValue;
                        } else {
                            // Firefox
                            labels[0].innerHTML = elementValue;
                        }
                    }
                }
                // Android native replay for CheckBox
                if (elementValue == "CheckBox" && subType == "click" && type == "checkbox") {
                    if (dijit) {
                        dijit.byNode(node).set("checked", true);
                    }
                } else if (subType == "click" && node.hasAttribute("templatetype") && node.getAttribute("templatetype") == "checkbox") {
                    var checkboxInput = document.getElementById(node.id + "-input");
                    if (checkboxInput) {
                        checkboxInput.checked = curStateIsChecked;
                        fireEvent(checkboxInput, 'change');
                    }
                }
                // Android native replay for Spinner
                if (subType == "ItemSelected" && tag == "select") {
                    if (node.options && node.options[0]) {
                        node.options[0].text = elementValue;
                    }
                }
                // Android native replay for SeekBar
                if (subType == "StopTrackingTouch") {
                    if (typeof dijit === "undefined") {
                        var seekBarInput = document.getElementById(node.id + "-input");
                        if (seekBarInput) {
                            seekBarInput.value = elementValue;
                            fireEvent(seekBarInput, 'change');
                        }
                        var seekBarRange = document.getElementById(node.id + "-range");
                        if (seekBarRange) {
                            seekBarRange.style.width = elementValue + "%";
                        }
                    } else if (dijit) {
                        dijit.byNode(node).set("value", elementValue);
                    }
                }
                // Android native replay for RadioButton
                if (subType == "click" && node.hasAttribute("templatetype") && node.getAttribute("templatetype") == "radioButton") {
                    var radioInput = document.getElementById(node.id + "-input");
                    if (radioInput) {
                        radioInput.checked = curStateIsSelected;
                        fireEvent(radioInput, 'change');
                    }
                } else if (type == "radio" && subType == "click") {
                    if (dijit) {
                        dijit.byNode(node).set("checked", true);
                    }
                }
                // Android native replay for RatingBar
                if (subType == "RatingChanged") {
                    var idSubFix = elementValue / (node.getAttribute("maxvalue") / node.getAttribute("numstars"));
                    var ratingInput = document.getElementById(node.id + idSubFix);
                    if (ratingInput) {
                        var inputs = node.getElementsByTagName('input');
                        for (index = 0; index < inputs.length; ++index) {
                            inputs[index].checked = 0;
                            fireEvent(inputs[index], 'change');
                        }
                        ratingInput.checked = 1;
                        fireEvent(ratingInput, 'change');
                    }
                }
                
                // iOS native UISwitch
                if (node.hasAttribute("templatetype") && node.getAttribute("templatetype") == "toggleButton") {
                    var toggleButtonInput = document.getElementById(node.id + "-input");
                    if (toggleButtonInput) {
                        toggleButtonInput.checked = curStateIsOn;
                        fireEvent(toggleButtonInput, 'change');
                    }
                }
                // iOS native UIStepper
                if (node.hasAttribute("templatetype") && node.getAttribute("templatetype") == "stepper" && curStateButtonIndex != -1) {
                    // Remove all the styles
                    var tds = node.getElementsByTagName("td");
                    // Highlight button selected
                    node = tds[curStateButtonIndex];
                }

                // iOS native UISegmentedBar
                if (node.hasAttribute("templatetype") && node.getAttribute("templatetype") == "segmentedBar" && curStateButtonIndex != -1) {
                    // Remove all the styles
                    var tds = node.getElementsByTagName("td");
					for (i = 0; i < tds.length; i++) {
					    tds[i].style.color = "inherit";
                    	tds[i].style.backgroundColor = "inherit";
                    	if (i == 0 || i == tds.length - 1) {
                    		tds[i].style.borderLeft = "inherit";
                    	}
					}
					// Clean and setup selected button
					tds[curStateButtonIndex].style.backgroundColor = '';
					tds[curStateButtonIndex].style.color = '';
					tds[curStateButtonIndex].className = 'tlSegmentedBarSelected';
                    // Highlight button selected
                    node = tds[curStateButtonIndex];
                }

                // iOS native UISlider
                if (node.hasAttribute("templatetype") && node.getAttribute("templatetype") == "slider") {
                	var sliderInput = document.getElementById(node.id + "-input");
                    var sliderRange = document.getElementById(node.id + "-range");
                    if (sliderInput && sliderRange && curStateValue != "") {
                        sliderInput.value = (curStateValue * 100) / curStateMaxValue;
                        sliderRange.style.width = ((sliderInput.value * node.offsetWidth) / 100) - 4;
                        fireEvent(sliderInput, 'change');
                    }
                }

                // iOS native UIPageControl
                if (node.hasAttribute("templatetype") && node.getAttribute("templatetype") == "pageControl" && curStateCurrentPage != -1) {
                    // Reset all the styles
                    var iObjects = node.getElementsByTagName("i");
                    for (i = 0; i < iObjects.length; i++) {
                        iObjects[i].className = "fa fa-circle tlPageControlIcon tlPageControlColor"
                    }

                    if (curState && typeof curState.currentPage != 'undefined' && curState.currentPage > -1) {
                        iObjects[curStateCurrentPage].className = "fa fa-circle tlPageControlIcon tlPageControlSelectedColor"
                    }
                }
                
                // iOS native UIPickerView
                if (node.hasAttribute("templatetype") && node.getAttribute("templatetype") == "pickerView" && curStateSelectedColumn != -1 && curStateVisibleCols != 'undefined') {
                    // Update the text on the selected column - standard is only 5 visible rows
                    for (i = 0; i < curStateVisibleCols.length; i++) {
                        var pickerLabel = document.getElementById(node.id + ",[colNo," + curStateSelectedColumn + "],[rowNo," + i + "]");
                        if (pickerLabel) {
                            pickerLabel.innerHTML = curStateVisibleCols[i];
                        }
                    }
                }

                // iOS native UIDatePicker curStateNumberOfColumns, curStateVisiblePics
                if (node.hasAttribute("templatetype") && node.getAttribute("templatetype") == "datePicker" && curStateNumberOfColumns != -1 && curStateVisiblePics != 'undefined') {
                    for (colNo = 0; colNo < curStateNumberOfColumns; colNo++) {
                        for (rowNo = 0; rowNo < curStateVisiblePics[colNo].length; rowNo++) {
                            if (colNo > 0) {
                                var pickerLabel = document.getElementById(node.id + ",[colNo," + colNo + "],[rowNo," + rowNo + "]");
                                if (pickerLabel) {
                                    pickerLabel.innerHTML = curStateVisiblePics[colNo][rowNo];
                                }
                            } else if (colNo == 0) {
                                var lblData = (curStateVisiblePics[colNo][rowNo]).split('.');
                                for (lblNo = 0; lblNo < lblData.length; lblNo++) {
                                    var pickerLabel = document.getElementById(node.id + ",[colNo," + colNo + "],[rowNo," + rowNo + "],[lblNo," + lblNo + "]");
                                    if (pickerLabel) {
                                        pickerLabel.innerHTML = lblData[lblNo];
                                    }
                                }
                            }
                        }
                    }
                }             

                // Handle scroll events. Scroll coordinates are in clientX/clientY.
                if (subType == "scroll") {
                    window.scroll(clientX, clientY);
                }
            }
        } catch (e) {  
        	//alert("catch e=" + e);
        }
    }
    
    function changeOptionText(elementId, elementName, elementXPath, value, idType) {
        var node = [];
        if (idType != 0) {
            node[0] = TeaLeaf_Client_tlGetNodeFromXPath_v2(elementId || elementXPath, idType);
            if (node[0] != null) {
            	var list = node[0].getElementsByTagName("option");
            	list[0].innerHTML = value;
            }
        }
    	
    }

    function execUIEvent(elementId, elementName, elementXPath, value, subType, idType, isParentLink, clientX, clientY, curStateIsChecked, curStateIsSelected, curStateIsOn, curStateButtonIndex, curStateValue, curStateMaxValue, curStateCurrentPage, curStateSelectedColumn, curStateVisibleCols, curStateNumberOfColumns, curStateVisiblePics) {
        var node = [];
        if (subType == "attention" || subType == "load" || subType == "unload" || subType == "resize")
            return true;
        // For scroll events just execute with window node, no highlighting.
        if (subType == "scroll") {
            execute(window, value, subType, exec, elementXPath, clientX, clientY, isParentLink, curStateIsChecked, curStateIsSelected, curStateIsOn, curStateButtonIndex, curStateValue, curStateMaxValue, curStateCurrentPage, curStateSelectedColumn, curStateVisibleCols, curStateNumberOfColumns, curStateVisiblePics);
            return true;
        }
        if (idType != 0) {
            node[0] = TeaLeaf_Client_tlGetNodeFromXPath_v2(elementId || elementXPath, idType);
        }

        var i;
        if (node.length == 0 || (node.length == 1 && node[0] == null)) {
            var e = document.getElementsByName(elementName);
            if (e.length >= 1) {
                for (i = 0; i < e.length; i++) {
                    node[i] = e[i];
                }
            } else {
            }
        }
        for (i = 0; i < node.length; i++) {
            execute(node[i], value, subType, elementXPath, clientX, clientY, isParentLink, curStateIsChecked, curStateIsSelected, curStateIsOn, curStateButtonIndex, curStateValue, curStateMaxValue, curStateCurrentPage, curStateSelectedColumn, curStateVisibleCols, curStateNumberOfColumns, curStateVisiblePics);
        }
        return true;
    }
    
    function setWebViewSrc(elementId, newSrc) {
    	document.getElementById(elementId).src = newSrc; 
    }
    
</script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://eaoc.perf.goacoustic.com/webapp/api/replay/replayProxyAsset?p=apath%3Dhttps%253A%252F%252Fadam-smycz.github.io%252Ftest-website%252Fassets%252Fcss%252Fpublic%252Ffont-case-style.css%26host%3Dhttps%253A%252F%252Feaoc.perf.goacoustic.com%26oid%3D20201119031409%26reload%3D0%26rmu%3D1">
    <base href="https://eaoc.perf.goacoustic.com/webapp/api/replay/replayProxyAsset?p=apath%3Dhttps%253A%252F%252Fadam-smycz.github.io%252Ftest-website%252F%26host%3Dhttps%253A%252F%252Feaoc.perf.goacoustic.com%26oid%3D20201119031409%26reload%3D0%26rmu%3D1">
    <link rel="stylesheet" href="https://eaoc.perf.goacoustic.com/webapp/api/replay/replayProxyAsset?p=apath%3Dhttps%253A%252F%252Fadam-smycz.github.io%252Ftest-website%252Fassets%252Fcss%252Fpublic%252Fbase.min.8d361898b.css%26host%3Dhttps%253A%252F%252Feaoc.perf.goacoustic.com%26oid%3D20201119031409%26reload%3D0%26rmu%3D1">
    
    <title>FONTS</title>
</head>

<body>
    
    <p class="default-font">Times New Roman</p>
    
    <p class="fancy-font">Remachine Script</p>
    <button type="submit" id="sbm-tva-personal-key" class="btn btn-primary submit-tva border-btn">Aceptar</button>
    <p class="btn-submenu"> 
        <span class=" icon"></span>
    </p>
    <p>
                <style>
                    @font-face {
                        font-style: normal;
                        font-family: festivalFont;
                        src: url(https://eaoc.perf.goacoustic.com/webapp/api/replay/replayProxyAsset?p=apath%3Dhttps%253A%252F%252Fadam-smycz.github.io%252Ftest-website%252Fassets%252FSuperFestival.ttf%26host%3Dhttps%253A%252F%252Feaoc.perf.goacoustic.com%26oid%3D20201119031409%26reload%3D0%26rmu%3D1) format("truetype");
                    }
                    p {
                        font-family: festivalFont;
                        color: rgb(33, 126, 56);
                    }
                </style>
                Super Festival Font
            </p>
    <div>
                <style>
                    @font-face {
                        font-style: normal;
                        font-family: ECIECITEST;
                        src: url(https://eaoc.perf.goacoustic.com/webapp/api/replay/replayProxyAsset?p=apath%3Dhttps%253A%252F%252Fadam-smycz.github.io%252Ftest-website%252Fassets%252Ffonts%252Fecifont-medium.woff2%26host%3Dhttps%253A%252F%252Feaoc.perf.goacoustic.com%26oid%3D20201119031409%26reload%3D0%26rmu%3D1) format("woff2");
                    }
                    div {
                        font-family: ECIECITEST;
                        font-size: 45px;
                        color: rgb(33, 1, 56);
                    }
                </style>
                ECIFONT SCRIPT Aceptar
            </div>
     


<slot class="red-rectangle">
                <style>
                    .red-rectangle {
                        width: 600px;
                        height: 200px;
                        background-color: red;
                        display: flex;
                        justify-content: center;
                        align-items: center;
                        color: white;
                        font-size: 24px;
                        font-weight: bold;
                }
                </style>
                LOL
            </slot><div id="tealeaf_hl_placeholder" style="display:none"><div id="tealeaf_hl_id_placeholder"><div id="tealeaf_hl_id"></div></div><div id="tealeaf_hl_idtype">-1</div></div><div id="tealeaf_hl_svg" style="display:none"></div><div id="tealeaf_hl_x" style="display:none"></div><div id="tealeaf_hl_y" style="display:none"></div><div id="tealeaf_hl_relx" style="display:none"></div><div id="tealeaf_hl_rely" style="display:none"></div></body></html>